<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>Guided Range Request Search (Proof of Concept)</title>
    <script>
        async function fetchRange(url, startByte, endByte) {
            // Example: Range: bytes=10000-10999
            const rangeHeader = `bytes=${startByte}-${endByte}`;
            const response = await fetch(url, {
                headers: { Range: rangeHeader }
            });
            if (!response.ok && response.status !== 206) {
                throw new Error(`Failed partial fetch from ${startByte} to ${endByte}, got status=${response.status}`);
            }
            return response.text();
        }

        function parseChunkForSubObjects(chunk) {
            // A more robust approach might parse the entire chunk as partial JSON,
            // but for demonstration, we'll do a simple substring + brace-tracking approach.

            let results = [];
            let index = 0;

            // We'll look for "................" : {...}
            const hashRegex = /"([0-9a-f]{32})"\s*:\s*\{/gi;
            let match;
            while ((match = hashRegex.exec(chunk)) !== null) {
                const foundHash = match[1];
                // The position in chunk of the '{'
                const openBracePos = chunk.indexOf('{', match.index);
                if (openBracePos < 0) continue; // shouldn't happen, but just in case

                // Now find the matching '}' using brace depth
                let braceDepth = 0;
                let endPos = -1;
                for (let i = openBracePos; i < chunk.length; i++) {
                    if (chunk[i] === '{') braceDepth++;
                    if (chunk[i] === '}') braceDepth--;
                    if (braceDepth === 0) {
                        endPos = i;
                        break;
                    }
                }
                if (endPos < 0) {
                    // No matching brace in this chunk. We skip it or break out
                    continue;
                }
                const subObjStr = chunk.slice(openBracePos, endPos + 1);

                // Attempt to parse it
                try {
                    const parsed = JSON.parse(subObjStr);
                    results.push([foundHash, parsed]);
                } catch (e) {
                    // Failed parse. Possibly truncated chunk, so skip this sub-object.
                }
                // Move on
                index = endPos + 1;
            }

            // Sort results by the hash (alphabetically). 
            // This is optional if the chunk is guaranteed to be sorted already, 
            // but safer to do so we can do min-hash / max-hash checks
            results.sort((a, b) => a[0].localeCompare(b[0]));
            return results;
        }

        // -----------------------------------------------------------------------------
        // The RECURSIVE guided search function
        // -----------------------------------------------------------------------------

        /**
         * @param {string} fileUrl - The URL of the big JSON file.
         * @param {string} searchHash - The MD5 hash we want to find, e.g. 'fa6a7e6...'.
         * @param {number} minByte    - Current lower bound of search in bytes.
         * @param {number} maxByte    - Current upper bound of search in bytes.
         * @param {string} minHash    - Guaranteed smallest hash in [minByte..maxByte].
         * @param {string} maxHash    - Guaranteed largest  hash in [minByte..maxByte].
         * @param {number} rangeSize  - Number of bytes to fetch in each attempt.
         * 
         * If found, returns { hash: <searchHash>, data: <the sub-object> }.
         * If definitely not found, returns null.
         * Otherwise, modifies the search bounds/rangeSize and tries again recursively.
         */
        async function guidedSearchRange(fileUrl, searchHash,
            minByte, maxByte,
            minHash, maxHash,
            rangeSize) {
            // 1) Quick base checks
            if (searchHash < minHash || searchHash > maxHash) {
                // The searchHash is out of the known [minHash..maxHash] range.
                return null;
            }
            if (minByte > maxByte) {
                // Byte range is inverted => not in file
                return null;
            }

            // We'll clamp the range request so we don't exceed maxByte
            let requestStart = minByte;
            let requestEnd = minByte + rangeSize - 1;
            if (requestEnd > maxByte) {
                requestEnd = maxByte;
            }

            // 2) Fetch that chunk via range request
            let chunkText;
            try {
                chunkText = await fetchRange(fileUrl, requestStart, requestEnd);
            } catch (err) {
                // Could not fetch for some reason => consider an error or fallback
                throw err;
            }

            // 3) Parse out sub-objects from that chunk
            const subObjects = parseChunkForSubObjects(chunkText);
            // Returns an array of [hash, data], sorted by hash.

            // If there are no sub-objects at all:
            if (subObjects.length === 0) {
                // We found no data in this chunk, so let's expand range drastically
                // and try again (same direction).
                const newRangeSize = rangeSize * 2.0; // +100%
                return await guidedSearchRange(
                    fileUrl, searchHash,
                    requestEnd + 1, // move forward
                    maxByte,
                    minHash,
                    maxHash,
                    newRangeSize
                );
            }

            // 4) Analyze sub-objects in this chunk
            const chunkMinHash = subObjects[0][0];
            const chunkMaxHash = subObjects[subObjects.length - 1][0];

            // Check if searchHash is directly in subObjects
            for (const [h, obj] of subObjects) {
                if (h === searchHash) {
                    // Found it
                    return { hash: h, data: obj };
                }
            }

            // If the chunk min-hash < searchHash < chunk max-hash,
            // and we didn't find it => the searchHash definitely isn't in the file
            // because we "jumped over" it in sorted order.
            if (chunkMinHash < searchHash && chunkMaxHash > searchHash) {
                // That means the sub-object doesn't exist.
                return null;
            }

            // If all sub-objects in this chunk are < searchHash
            if (chunkMaxHash < searchHash) {
                // We need to keep searching forward.
                // We'll shift minByte, update minHash, and increase range by 30%.
                const newMinByte = requestEnd + 1;
                const newMinHash = chunkMaxHash; // everything up to chunkMaxHash is done
                const newRangeSize = Math.floor(rangeSize * 1.3);

                return await guidedSearchRange(
                    fileUrl, searchHash,
                    newMinByte, maxByte,
                    newMinHash, maxHash,
                    newRangeSize
                );
            }

            // If all sub-objects in this chunk are > searchHash
            if (chunkMinHash > searchHash) {
                // We need to search earlier in the file.
                // We'll move the maxByte boundary to the start of this chunk minus 1,
                // update maxHash to chunkMinHash, and increase range by 30%.
                const newMaxByte = requestStart - 1;
                const newMaxHash = chunkMinHash;
                const newRangeSize = Math.floor(rangeSize * 1.3);

                return await guidedSearchRange(
                    fileUrl, searchHash,
                    minByte, newMaxByte,
                    minHash, newMaxHash,
                    newRangeSize
                );
            }

            // If we somehow didn't handle a scenario, return null.
            return null;
        }

        // -----------------------------------------------------------------------------
        // Example usage or demonstration
        // -----------------------------------------------------------------------------
        async function demo() {
            const fileUrl = "data_doc/cachefilter_population/location_name/fa6.json";
            // The parameters for the initial call:
            const searchHash = "fa6a7e67833806738913d21164273f40";
            const minByte = 0;
            const maxByte = 999999999; // or the actual size of the file
            const minHash = "fa600000000000000000000000000000";
            const maxHash = "fa6fffffffffffffffffffffffffffff";
            const rangeSize = 5000;  // start reading 5KB chunks

            try {
                const result = await guidedSearchRange(
                    fileUrl, searchHash,
                    minByte, maxByte,
                    minHash, maxHash,
                    rangeSize
                );
                if (result) {
                    console.log("Found sub-object for hash", result.hash, result.data);
                } else {
                    console.log("Sub-object not found or definitely not in file.");
                }
            } catch (err) {
                console.error("Search error:", err);
            }
        }

        // For demonstration, we call `demo()` when the page loads
        window.addEventListener('load', demo);

    </script>
</head>

<body>
    <h1>Guided Range Request JSON Search â€“ Proof of Concept</h1>
    <p>
        Open the browser console to see the results of the <code>demo()</code> function.
    </p>
</body>

</html>